WITH filtros_raw AS (
  SELECT
    sf.id_utilizador,
    sf.ano,
    sf.data_registo,
 
    -- certificacoes em CSV -> rótulos legíveis (ignora vazios)
    array_to_string(
      ARRAY(
        SELECT CASE TRIM(val)
          WHEN 'globalgap' THEN 'GLOBALG.A.P.'
          WHEN 'grasp'     THEN 'GRASP'
          WHEN 'spring'    THEN 'SPRING'
          WHEN 'prodi'     THEN 'PRODI'
          ELSE INITCAP(REPLACE(TRIM(val), '_', ' '))
        END
        FROM unnest(string_to_array(COALESCE(sf.certificacoes, ''), ',')) AS val
        WHERE TRIM(val) <> ''
      ),
      ', '
    ) AS certificacoes,
 
    -- sistemas_producao em CSV -> rótulos legíveis (ignora vazios)
    array_to_string(
      ARRAY(
        SELECT CASE TRIM(val)
          WHEN 'sp_culturas_anuais'       THEN 'Culturas anuais'
          WHEN 'sp_culturas_permanentes'  THEN 'Culturas permanentes'
          WHEN 'sp_producao_animal'       THEN 'Produção animal'
          ELSE INITCAP(REPLACE(TRIM(val), '_', ' '))
        END
        FROM unnest(string_to_array(COALESCE(sf.sistemas_producao, ''), ',')) AS val
        WHERE TRIM(val) <> ''
      ),
      ', '
    ) AS sistemas_producao,
 
    -- dimensao -> nome legível
    CASE TRIM(COALESCE(sf.dimensao, ''))
      WHEN 'de_pequena' THEN 'Pequena'
      WHEN 'de_media'   THEN 'Média'
      WHEN 'de_grande'  THEN 'Grande'
      WHEN ''           THEN NULL
      ELSE INITCAP(REPLACE(TRIM(sf.dimensao), '_', ' '))
    END AS dimensao
  FROM selecoes_filtros sf
  WHERE sf.ano = {{ Select_year.selectedOptionValue }}
),
 
-- última seleção de filtros por utilizador/ano (data usada só para ordenar)
filtros AS (
  SELECT DISTINCT ON (fr.id_utilizador, fr.ano)
    fr.id_utilizador,
    fr.ano,
    fr.data_registo,
    fr.certificacoes,
    fr.sistemas_producao,
    fr.dimensao
  FROM filtros_raw fr
  ORDER BY fr.id_utilizador, fr.ano, fr.data_registo DESC
),
 
-- KPIs por utilizador/ano
contagens AS (
  SELECT
    r.id_utilizador,
    r.ano,
    COUNT(*) AS respostas_total,
    SUM(CASE WHEN r.validacao = 'S' THEN 1 ELSE 0 END) AS respostas_validadas,
    SUM(CASE WHEN r.validacao = 'N' THEN 1 ELSE 0 END) AS respostas_nao_validadas,
    MAX(r.data_hora_submissao) AS ultima_submissao_utc
  FROM respostas r
  WHERE r.ano = {{ Select_year.selectedOptionValue }}
  GROUP BY r.id_utilizador, r.ano
),
 
-- última validação por utilizador/ano (data + quem validou)
ultima_validacao AS (
  SELECT DISTINCT ON (r.id_utilizador, r.ano)
    r.id_utilizador,
    r.ano,
    r.data_hora_validacao AS ultima_validacao_utc,
    r.tecnico_validacao   -- NIF do técnico
  FROM respostas r
  WHERE r.ano = {{ Select_year.selectedOptionValue }}
    AND r.validacao = 'S'
    AND r.data_hora_validacao IS NOT NULL
  ORDER BY r.id_utilizador, r.ano, r.data_hora_validacao DESC
)
 
SELECT
  u.nome,
  u.nif,
  u.email,
  c.ano,
 
  -- filtros (sem exibir a data de registo dos filtros)
  f.certificacoes,
  f.sistemas_producao,
  f.dimensao,
 
  -- KPIs
  c.respostas_total,
  c.respostas_validadas,
  c.respostas_nao_validadas,
 
  -- última submissão convertida para Europe/Lisbon
  TO_CHAR(
    (c.ultima_submissao_utc AT TIME ZONE 'UTC') AT TIME ZONE 'Europe/Lisbon',
    'DD/MM/YYYY - HH24:MI:SS'
  ) AS ultima_submissao,
 
  -- técnico e data da última validação (com fallback quando não há validação)
  COALESCE(utech.nome, '—') AS tecnico_validacao_nome,
  COALESCE(
    TO_CHAR(
      (uv.ultima_validacao_utc AT TIME ZONE 'UTC') AT TIME ZONE 'Europe/Lisbon',
      'DD/MM/YYYY - HH24:MI:SS'
    ),
    'Validação pendente'
  ) AS data_ultima_validacao
 
FROM contagens c
LEFT JOIN utilizadores u
  ON u.nif = c.id_utilizador
LEFT JOIN filtros f
  ON f.id_utilizador = c.id_utilizador AND f.ano = c.ano
LEFT JOIN ultima_validacao uv
  ON uv.id_utilizador = c.id_utilizador AND uv.ano = c.ano
LEFT JOIN utilizadores utech
  ON utech.nif = uv.tecnico_validacao
 
ORDER BY
  c.respostas_validadas DESC,
  COALESCE(u.nome, c.id_utilizador) ASC;